/**
 * Phase 11: PDF Export for Reports
 * Generate executive-ready PDF reports from Guardian scans
 * Phase C: Real PDF rendering using Playwright
 */

const fs = require('fs');
const path = require('path');
const { GuardianBrowser } = require('../guardian/browser');

/**
 * Convert HTML report to real PDF using Playwright
 * Produces binary PDF with valid %PDF header
 */
async function generatePDFReal(reportPath, outputPath) {
  // Read the HTML report
  if (!fs.existsSync(reportPath)) {
    throw new Error(`Report not found: ${reportPath}`);
  }
  
  const html = fs.readFileSync(reportPath, 'utf-8');
  const metadata = extractReportMetadata(html);
  
  // Use Playwright to render to PDF
  const browser = new GuardianBrowser();
  
  try {
    await browser.launch(30000, { headless: true });
    
    // Set content as HTML
    await browser.page.setContent(html, { waitUntil: 'networkidle' });
    
    // Render to PDF (binary format with %PDF header)
    const pdfBuffer = await browser.page.pdf({
      format: 'A4',
      margin: { top: '1cm', bottom: '1cm', left: '1cm', right: '1cm' },
    });
    
    // Write binary PDF
    fs.writeFileSync(outputPath, pdfBuffer);
    
    await browser.close();
    
    return {
      outputPath,
      size: fs.statSync(outputPath).size,
      metadata,
      format: 'application/pdf',
      isRealPDF: true,
    };
  } catch (error) {
    await browser.close().catch(() => {});
    throw error;
  }
}

/**
 * Convert HTML report to PDF
 * Wrapper that uses real PDF rendering
 */
function generatePDF(reportPath, outputPath) {
  // For synchronous API compatibility, we use generatePDFReal async version
  // This function should be called via async wrapper
  throw new Error('Use generatePDFAsync for real PDF rendering');
}

/**
 * Async version - generates real PDF
 */
async function generatePDFAsync(reportPath, outputPath) {
  return generatePDFReal(reportPath, outputPath);
}

/**
 * Extract metadata from HTML report
 */
function extractReportMetadata(html) {
  const metadata = {
    url: extractBetween(html, '<h2>URL:', '</h2>') || 'Unknown',
    timestamp: extractBetween(html, '<p>Scanned:', '</p>') || 'Unknown',
    verdict: extractVerdict(html),
    riskLevel: extractRiskLevel(html),
    flags: extractFlags(html),
    summary: extractBetween(html, '<h3>Executive Summary</h3>', '<h3>') || '',
  };
  
  return metadata;
}

/**
 * Extract text between two markers
 */
function extractBetween(text, start, end) {
  const startIndex = text.indexOf(start);
  if (startIndex === -1) return null;
  
  const searchStart = startIndex + start.length;
  const endIndex = text.indexOf(end, searchStart);
  if (endIndex === -1) return null;
  
  return text.substring(searchStart, endIndex).trim().replace(/<[^>]*>/g, '');
}

/**
 * Extract verdict from HTML
 */
function extractVerdict(html) {
  if (html.includes('PASSED')) return 'PASSED';
  if (html.includes('FAILED')) return 'FAILED';
  if (html.includes('WARN')) return 'WARN';
  return 'UNKNOWN';
}

/**
 * Extract risk level
 */
function extractRiskLevel(html) {
  if (html.includes('HIGH RISK')) return 'HIGH';
  if (html.includes('MEDIUM RISK')) return 'MEDIUM';
  if (html.includes('LOW RISK')) return 'LOW';
  return 'UNKNOWN';
}

/**
 * Extract flags from report
 */
function extractFlags(html) {
  const flags = [];
  
  const flagSection = extractBetween(html, '<h3>Flags Detected</h3>', '<h3>');
  if (!flagSection) return flags;
  
  const lines = flagSection.split('\n');
  for (const line of lines) {
    const match = line.match(/([A-Z_]+):/);
    if (match) {
      flags.push(match[1]);
    }
  }
  
  return flags;
}

/**
 * Generate simplified PDF (text format)
 * In production, use a proper PDF library
 */
function generateSimplifiedPDF(metadata) {
  const lines = [
    '='.repeat(80),
    'GUARDIAN SECURITY REPORT',
    '='.repeat(80),
    '',
    `URL: ${metadata.url}`,
    `Scanned: ${metadata.timestamp}`,
    `Verdict: ${metadata.verdict}`,
    `Risk Level: ${metadata.riskLevel}`,
    '',
    '-'.repeat(80),
    'EXECUTIVE SUMMARY',
    '-'.repeat(80),
    '',
    metadata.summary || 'No summary available',
    '',
    '-'.repeat(80),
    'FLAGS DETECTED',
    '-'.repeat(80),
    '',
  ];
  
  if (metadata.flags.length === 0) {
    lines.push('No flags detected');
  } else {
    for (const flag of metadata.flags) {
      lines.push(`- ${flag}`);
    }
  }
  
  lines.push('');
  lines.push('='.repeat(80));
  lines.push('Generated by Guardian - Enterprise Edition');
  lines.push('='.repeat(80));
  
  return lines.join('\n');
}

/**
 * Export report to PDF (async)
 * Main entry point - uses real PDF rendering
 */
async function exportReportToPDFAsync(reportId, outputDir = null) {
  // Find report file
  const artifactsDir = path.join(process.cwd(), 'artifacts');
  
  let reportPath = null;
  
  // Try direct path first
  if (fs.existsSync(reportId)) {
    reportPath = reportId;
  } else {
    // Search in artifacts
    const reportFile = path.join(artifactsDir, reportId, 'index.html');
    if (fs.existsSync(reportFile)) {
      reportPath = reportFile;
    }
  }
  
  if (!reportPath) {
    throw new Error(`Report not found: ${reportId}`);
  }
  
  // Generate output path
  const basename = path.basename(reportPath, '.html');
  const outputFilename = `${basename}-report.pdf`;
  const outputPath = outputDir
    ? path.join(outputDir, outputFilename)
    : path.join(path.dirname(reportPath), outputFilename);
  
  return generatePDFAsync(reportPath, outputPath);
}

/**
 * Legacy synchronous version (for backward compatibility)
 */
function exportReportToPDF(reportId, outputDir = null) {
  throw new Error('Use exportReportToPDFAsync for PDF export');
}

/**
 * List available reports for export
 */
function listAvailableReports() {
  const artifactsDir = path.join(process.cwd(), 'artifacts');
  
  if (!fs.existsSync(artifactsDir)) {
    return [];
  }
  
  const reports = [];
  const entries = fs.readdirSync(artifactsDir, { withFileTypes: true });
  
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const reportFile = path.join(artifactsDir, entry.name, 'index.html');
      if (fs.existsSync(reportFile)) {
        const stats = fs.statSync(reportFile);
        reports.push({
          id: entry.name,
          path: reportFile,
          modifiedAt: stats.mtime.toISOString(),
        });
      }
    }
  }
  
  return reports.sort((a, b) => 
    new Date(b.modifiedAt) - new Date(a.modifiedAt)
  );
}

module.exports = {
  exportReportToPDF,
  exportReportToPDFAsync,
  listAvailableReports,
  generatePDF: generatePDFAsync,
  generatePDFAsync,
};
