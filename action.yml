name: "ODAVL Guardian"
description: "Run ODAVL Guardian reality check against a URL and upload artifacts"
branding:
  color: blue
  icon: shield

inputs:
  url:
    description: "Target URL to evaluate (e.g., https://example.com)"
    required: true
  preset:
    description: "Guardian preset (e.g., landing)"
    required: false
    default: "landing"
  config:
    description: "Path to guardian.config.json (optional)"
    required: false
  fail-on:
    description: "Failure policy for verdicts: none | friction | risk | any"
    required: false
    default: "any"
  artifacts:
    description: "Artifacts output directory"
    required: false
    default: ".odavlguardian"

outputs:
  verdict:
    description: "Final Guardian verdict (READY | FRICTION | DO_NOT_LAUNCH)"
    value: "${{ steps.set.outputs.verdict }}"
  exit-code:
    description: "Guardian exit code"
    value: "${{ steps.set.outputs.exit-code }}"
  run-id:
    description: "Guardian run identifier"
    value: "${{ steps.set.outputs.run-id }}"

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      shell: bash
      env:
        URL: "${{ inputs.url }}"
        FAIL_ON: "${{ inputs.fail-on }}"
      run: |
        set -euo pipefail
        if [ -z "$URL" ]; then
          echo "::error::Input 'url' is required and cannot be empty"
          exit 1
        fi
        if ! echo "$URL" | grep -qE '^https?://'; then
          echo "::error::Input 'url' must start with http:// or https://"
          exit 1
        fi
        case "$FAIL_ON" in
          none|friction|risk|any)
            ;;
          *)
            echo "::error::Input 'fail-on' must be one of: none, friction, risk, any"
            exit 1
            ;;
        esac
        echo "Inputs validated: url=$URL, fail-on=$FAIL_ON"

    - name: Setup Node 20
      uses: actions/setup-node@v4
      with:
        node-version: "20"
        cache: npm

    - name: Verify npm and Node environment
      shell: bash
      run: |
        set -euo pipefail
        echo "Node version: $(node --version)"
        echo "npm version: $(npm --version)"
        node -e "console.log('Node.js is functional')"

    - name: Restore Playwright browser cache
      uses: actions/cache@v4
      with:
        path: ~/.cache/ms-playwright
        key: playwright-cache-${{ runner.os }}-v1.48.2
        restore-keys: |
          playwright-cache-${{ runner.os }}-

    - name: Install Playwright (browsers & OS deps)
      shell: bash
      run: |
        set -euo pipefail
        echo "Installing Playwright chromium with required dependencies"
        npx -y playwright@1.48.2 install --with-deps chromium
        if ! ls ~/.cache/ms-playwright/chromium-*/chrome-linux/chrome >/dev/null 2>&1; then
          echo "::error::Playwright chromium installation failed or browser not found"
          echo "Contents of ~/.cache/ms-playwright:"
          ls -la ~/.cache/ms-playwright 2>/dev/null || echo "(directory does not exist)"
          exit 1
        fi
        BROWSER_PATH=$(ls ~/.cache/ms-playwright/chromium-*/chrome-linux/chrome 2>/dev/null | head -n 1)
        echo "✓ Playwright chromium installed: $BROWSER_PATH"

    - name: Run Guardian with retry logic
      shell: bash
      env:
        ARTIFACT_DIR: "${{ inputs.artifacts }}"
        URL: "${{ inputs.url }}"
        PRESET: "${{ inputs.preset }}"
        CONFIG: "${{ inputs.config }}"
        TIMEOUT_SECONDS: "300"
      run: |
        set -euo pipefail
        mkdir -p "$ARTIFACT_DIR"
        ARGS=(reality --url "$URL" --artifacts "$ARTIFACT_DIR")
        if [ -n "$PRESET" ]; then ARGS+=(--preset "$PRESET"); fi
        if [ -n "$CONFIG" ]; then ARGS+=(--config "$CONFIG"); fi
        
        MAX_ATTEMPTS=3
        ATTEMPT=1
        EXIT_CODE=0
        RETRY_DELAYS=(2 5)
        TIMEOUT_BUFFER=$((TIMEOUT_SECONDS - 30))
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Guardian execution attempt $ATTEMPT of $MAX_ATTEMPTS"
          echo "Running: npx @odavl/guardian ${ARGS[*]}"
          
          EXIT_CODE=0
          timeout "$TIMEOUT_BUFFER" npx -y @odavl/guardian "${ARGS[@]}" || EXIT_CODE=$?
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "✓ Guardian completed successfully"
            break
          elif [ $EXIT_CODE -eq 124 ]; then
            echo "::warning::Guardian timed out (exit 124)"
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              DELAY=${RETRY_DELAYS[$((ATTEMPT-1))]}
              echo "Retrying in ${DELAY}s..."
              sleep "$DELAY"
              ATTEMPT=$((ATTEMPT+1))
              continue
            else
              echo "::error::Guardian timed out after $MAX_ATTEMPTS attempts"
              exit 124
            fi
          elif [ $EXIT_CODE -eq 1 ] || [ $EXIT_CODE -eq 2 ]; then
            echo "Guardian completed with verdict exit code: $EXIT_CODE"
            break
          else
            echo "::warning::Guardian failed with exit code $EXIT_CODE (attempt $ATTEMPT of $MAX_ATTEMPTS)"
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              DELAY=${RETRY_DELAYS[$((ATTEMPT-1))]}
              echo "Retrying in ${DELAY}s..."
              sleep "$DELAY"
              ATTEMPT=$((ATTEMPT+1))
              continue
            else
              echo "::error::Guardian failed after $MAX_ATTEMPTS attempts"
              exit $EXIT_CODE
            fi
          fi
        done
        
        echo "Listing artifacts:"
        ls -la "$ARTIFACT_DIR" || echo "(artifacts directory does not exist)"
        echo "GUARDIAN_EXIT_CODE=$EXIT_CODE" >> "$GITHUB_ENV"

    - name: Extract decision and set outputs
      id: set
      shell: bash
      env:
        ARTIFACT_DIR: "${{ inputs.artifacts }}"
        EXIT_CODE: "${{ env.GUARDIAN_EXIT_CODE }}"
      run: |
        set -euo pipefail
        
        if [ "$EXIT_CODE" -eq 124 ]; then
          echo "::error::Guardian execution timed out; cannot extract decision"
          exit 1
        fi
        
        DECISION="$ARTIFACT_DIR/decision.json"
        if [ ! -f "$DECISION" ]; then
          DECISION=$(ls -1 "$ARTIFACT_DIR"/*/decision.json 2>/dev/null | head -n 1 || true)
        fi
        if [ -z "$DECISION" ] || [ ! -f "$DECISION" ]; then
          echo "::error::Guardian did not produce decision.json in $ARTIFACT_DIR"
          ls -la "$ARTIFACT_DIR" 2>/dev/null || echo "(artifacts directory does not exist)"
          exit 1
        fi
        export DECISION
        node -e '
          const fs=require("fs");
          const p=process.env.DECISION;
          const exitCode=parseInt(process.env.EXIT_CODE||"0");
          try {
            const j=JSON.parse(fs.readFileSync(p,"utf8"));
            const v=j.finalVerdict||"UNKNOWN";
            const e=typeof j.exitCode==="number"?j.exitCode:exitCode;
            const r=j.runId||"";
            const out=process.env.GITHUB_OUTPUT;
            if (!v || v === "UNKNOWN") {
              console.error("ERROR: finalVerdict missing or invalid in decision.json");
              process.exit(1);
            }
            if(!["READY","FRICTION","DO_NOT_LAUNCH"].includes(v)){
              console.error("ERROR: finalVerdict invalid value: "+v);
              process.exit(1);
            }
            if(![0,1,2].includes(e)){
              console.error("ERROR: exitCode must be 0, 1, or 2");
              process.exit(1);
            }
            fs.appendFileSync(out, `verdict=${v}\n`);
            fs.appendFileSync(out, `exit-code=${e}\n`);
            fs.appendFileSync(out, `run-id=${r}\n`);
            console.log(`Decision extracted: verdict=${v}, exit-code=${e}, run-id=${r}`);
          } catch (e) {
            console.error("ERROR: Failed to parse decision.json:", e.message);
            process.exit(1);
          }
        '

    - name: Upload Guardian artifacts
      id: upload
      continue-on-error: true
      uses: actions/upload-artifact@v4
      with:
        name: "guardian-${{ steps.set.outputs.run-id }}"
        path: "${{ inputs.artifacts }}"
        if-no-files-found: error
        retention-days: 30

    - name: Validate artifact upload
      shell: bash
      env:
        UPLOAD_STATUS: "${{ steps.upload.outcome }}"
      run: |
        set -euo pipefail
        if [ "$UPLOAD_STATUS" = "failure" ]; then
          echo "::warning::Artifact upload failed, but Guardian decision is still available"
        fi
        echo "Upload status: $UPLOAD_STATUS"

    - name: Enforce fail-on policy
      shell: bash
      env:
        VERDICT: "${{ steps.set.outputs.verdict }}"
        FAIL_ON: "${{ inputs.fail-on }}"
      run: |
        set -euo pipefail
        echo "Verdict=$VERDICT, Fail-On=$FAIL_ON"
        fail=0
        case "$FAIL_ON" in
          none)
            fail=0
            ;;
          friction)
            [ "$VERDICT" = "FRICTION" ] && fail=1 || fail=0
            ;;
          risk)
            [ "$VERDICT" = "DO_NOT_LAUNCH" ] && fail=1 || fail=0
            ;;
          any)
            { [ "$VERDICT" = "FRICTION" ] || [ "$VERDICT" = "DO_NOT_LAUNCH" ]; } && fail=1 || fail=0
            ;;
          *)
            echo "::error::Unknown fail-on '$FAIL_ON' (allowed: none|friction|risk|any)"
            exit 1
            ;;
        esac
        if [ "$fail" -eq 1 ]; then
          echo "::error::Guardian verdict '$VERDICT' triggers failure per fail-on=$FAIL_ON"
          exit 1
        fi
        echo "Guardian check passed (verdict=$VERDICT, fail-on=$FAIL_ON)"
